---
layout: docs
title: Collections
---
# Collections

Normcore provides several collections that can be used to synchronize data in real-time. These collections are designed to be atomic even with multiple clients making simultaneous changes to them, and so they have restrictions that you may not see in a typical C# collection.

## Transactional Collections
Transactional collections do not reflect a change to the collection until the server has confirmed the change. They will also reject a change if another client has modified the same key before your change was received by the server. This is implemented by storing a version for the collection and each key.

### StringKeyDictionary
StringKeyDictionary works very similarly to a `Dictionary<string, ModelType>`. Any string key is supported, and behind the scenes, is only used the first time a value is synchronized. From that point on, an ID is generated by the server and used for future updates to keep bandwidth usage to an absolute minimum.


## Non-Transactional Collections
// TODO: What's another word for Non-Transactional?
Non-transactional collections work similarly to RealtimeModels in that changes are reflected instantly, and the server merges changes by using a last-client-wins approach. If you need to control how a merge conflict is handled, utilize a Transaction Collection instead.

### RealtimeSet
The most commonly used collection is RealtimeSet. RealtimeSet is an unordered collection of RealtimeModels. Models can be added and removed at runtime by any client simultaneously without conflict.

RealtimeSet is the collection used by Realtime in order to represents instantiated prefabs. All prefabs are stored in a RealtimeSet of RealtimeViewModels. Realtime uses the presence of the model to signal that a prefab exists and should be instantiated if it doesn't exist yet.

// TODO: Make this better
Models can be easily added or removed from RealtimeSet because it has no concept of order.

### RealtimeDictionary
RealtimeDictionary works similarly to `Dictionary<uint, ModelType>`. It's commonly used to represent a model that can have fields that are dynamically added or removed at runtime. For example, if you need to store the score for N players, you could create a ScoreModel and store instances of it in a RealtimeDictionary, using each player's clientID as the key.

### RealtimeArray
RealtimeArray is equivalent to a `List<ModelTyle>` that only supports adding elements. Because the contents are sorted by index, removing items by index is not supported as the server cannot correctly solve merge-conflicts if two clients attempt to remove an object at an index at the same time.

RealtimeArray is generally used for things like drawing brush strokes where a series of models need to be added in order.

Tip: If you need a sorted collection that supports random removal, we generally recommend using RealtimeDictionary with the key as the item index, or a RealtimeSet of models that can be sorted deterministically on all clients when the contents change.

